<h3>STM8 - работа в Linux.</h3>
<p>Не для кого не секрет, что сейчас (2026 год) 8-битные микроконтроллеры от STM  не очень популярны. Почему? Я тоже задался этим вопросом. МК не дорогие, с  богатой переферией, но... По ним очень мало информации. Есть конечно даташиты  и референсмануалы, но для новичков (и для меня) там малова-то информации. Да  и все статьи заточены под "помигаем диодом" практически без всяких объяснений, использование SPL, и в большинстве случаев, использование под Windows. Вроде бы немного памяти программ. Почему "вроде бы"? Потому, что однажды создал код с SPL, который занял 1.5кБ. Потом был код, который не использовал сторонние библиотеки, а делал он ровно то же самое, и занял он около 300Б.</p>
<p>Да и очень хотелось понять "что к чему" в использовании данного МК. Так сказать, заглянуть под капот.</p>
<p>Ну, и... Понеслось!</p>
<h4>Моя система.</h4>
<p>Все опыты проводились на ОС Debian 12. Графический интерфейс есть, но он мне не понадобился. Вся работа из командной строки.</p>
<h4>Набор кода.</h4>
<p>Код набирал в консольной версии VIM. Не потому, что хотел выпендриться. Нет. Просто привык к нему.</p>
<h4>Чем компилировал код.</h4>
<p>Код компилировал с помощью <b>sdcc</b>. Установка компилятора проблем не вызвала. Собирал из исходников. Инструкция прилагалась. Коротенькая, но простая и понятная. Что-то вроде
<pre>
  "скачайте архив с исходным кодом.
   распакуте. зайдите в директория с распакованными файлами.
   скомпилируйте исходный код.
   скопируйте все по пути ...
   запустите.
   проверьте."
</pre>
В общем все понятно и работает. Чуть повозился с подключаемыми файлами и собственными библиотеками.</p>
<p>В чем заключалась возня. Необходимо указать пути поиска при компиляции. А именно...</p>
<pre>
  #include &lt;my_inc.h&gt;
</pre>
обязательно вызовет ошибку. sdcc просто не будет знать, где искать этот <b>my_inc.h</b>.</p>
<p>Приступим к возне. Мануал по sdcc знакомит с большим количеством переменных окружения. Мне понадобились всего две:</p>
<p><b>SDCC_INCLUDE</b> и <b>SDCC_LIB</b></p>
<p>Первая говорит sdcc, где искать включаемые файлы, вторая указывает место расположения УЖЕ СКОМПИЛИРОВАННЫХ библиотек функций. Я добавил экспорт этих переменных в файл <b>.bashrc</b>. Добавление в моем .bashrc выглядит вот так:
<pre>
  export SDCC_INCLUDE=/home/&lt;имя_пользователя&gt;/documents/electronic/stm8/inc
  export SDCC_LIB=/home/&lt;имя_пользователя&gt;/documents/electronic/stm8/lib
</pre>
Пути могут быть любыми, но нужно помнить, что путь должен существовать и быть доступным(sdcc должен иметь права на чтение самих директорий и файлов в них).</p>
<p>Вот, пожалуй, и все, что необходимо настроить для начала использования. Ах да! Есть еще одна "мелочь". При компиляции с использованием скомпилированных библиотек, все же придется указать имя этой библиотеки в командной строке. Это будет параметр <b>-L &lt;имя_библиотеки&gt;</b>. Зачем? Затем, что в переменной окружения указан лишь путь поиска. О том, что нужно использовать какую-то библиотеку из этой директории, придется сообщить sdcc отдельно. В отдельном параметре. Здесь все похоже на gcc. )))</p>
<h4>Чем "залить" прошивку.</h4>
<p>Прошивку я производил с помощью <b>stm8flash</b> и китайсокго клона <b>ST-Link</b>. stm8flash устанавливается либо из репозиториев (если он там есть), либо собирается из исходников. Я собрал из исходников. Для дальнейшего использования требуется небольшая настройка ОС. А именно: мои двоичные файлы не находятся в bin-директориях системы. Поэтому пришлось добавить путь к двоичному файлу в PATH. Следующая настройка: автомонтирование st-link при подключении. В сети есть много примеров создания файлов <b>.rules</b>. По началу хотель отфутболить в гугл, но потом передумал. Это ведь Шпаргалка. А в исходниках stm8flash нет краткой инструкции по настройке автомонтирования st-link. Так что начнем...
<pre>
  Создаем 4 файла и копируем их в <b>/etc/udev/rules.d/</b>
  Файл <b>49-stlinkv1.rules</b>:
--------------------------------
  # stm32 discovery boards, with onboard st/linkv1
  # ie, STM32VL.

  SUBSYSTEMS=="usb", ATTRS{idVendor}=="0483", ATTRS{idProduct}=="3744", \
      MODE="660", GROUP="plugdev", TAG+="uaccess", \
      SYMLINK+="stlinkv1_%n"
---------------------------------

  Файл <b>49-stlinkv2.rules</b>:
---------------------------------
  # stm32 discovery boards, with onboard st/linkv2
  # ie, STM32L, STM32F4.

  SUBSYSTEMS=="usb", ATTRS{idVendor}=="0483", ATTRS{idProduct}=="3748", \
      MODE="660", GROUP="plugdev", TAG+="uaccess", \
      SYMLINK+="stlinkv2_%n"
----------------------------------

  Файл <b>49-stlinkv2-1.rules</b>:
----------------------------------
  # stm32 nucleo boards, with onboard st/linkv2-1
  # ie, STM32F0, STM32F4.

  SUBSYSTEMS=="usb", ATTRS{idVendor}=="0483", ATTRS{idProduct}=="374b", \
      MODE="660", GROUP="plugdev", TAG+="uaccess", \
      SYMLINK+="stlinkv2-1_%n"

  SUBSYSTEMS=="usb", ATTRS{idVendor}=="0483", ATTRS{idProduct}=="3752", \
      MODE="660", GROUP="plugdev", TAG+="uaccess", \
      SYMLINK+="stlinkv2-1_%n"
----------------------------------
  
  Файл <b>49-stlinkv3.rules</b>:
----------------------------------
  # stlink-v3 boards (standalone and embedded) in usbloader mode and standard (debug) mode

  SUBSYSTEMS=="usb", ATTRS{idVendor}=="0483", ATTRS{idProduct}=="374d", \
      MODE="660", GROUP="plugdev", TAG+="uaccess", \
      SYMLINK+="stlinkv3loader_%n"

  SUBSYSTEMS=="usb", ATTRS{idVendor}=="0483", ATTRS{idProduct}=="374e", \
      MODE="660", GROUP="plugdev", TAG+="uaccess", \
      SYMLINK+="stlinkv3_%n"

  SUBSYSTEMS=="usb", ATTRS{idVendor}=="0483", ATTRS{idProduct}=="374f", \
      MODE="660", GROUP="plugdev", TAG+="uaccess", \
      SYMLINK+="stlinkv3_%n"

  SUBSYSTEMS=="usb", ATTRS{idVendor}=="0483", ATTRS{idProduct}=="3753", \
      MODE="660", GROUP="plugdev", TAG+="uaccess", \
      SYMLINK+="stlinkv3_%n"
------------------------------------
</pre>
Не могу припомнить, нужно ли перечитать правила udev. Данные файлы работают так: при подключении st-link, он определяется как устройство с idVendor и idProduct. Это можно увидеть введя команду <b>lsusb</b>(в выводе команды смотрим в коммент /описание устройства), либо по команде <b>dmesg</b>(более подробная информация, но требует root).  Затем udev монтирует его и дает ему имя в /dev директории соответственно этим id. stm8flash принимает одним из параметров имя файла устройства в /dev директории. У меня st-linkv2, поэтому в /dev появляется файл устройства <b>stlinkv2_x</b>, где x может меняться.</p>
<p> Теперь по самим st-link. К сожалению клоны у китайцев бывают разные. ((( Несколько штук, купленных в России на Озон'е были хоть и разного цвета, но с одним недостатком: при попытке прошивки с помощью stm8flash, постоянно вываливалась ошибка. В Windows через фирменную утилиту чтение и запись проходили нормально. После "гугления" стало понятно, что либо stm8flash чего-то не так делает, либо пакет usblib, который она использует, делает что-то не то. Не долго думая, решил взять другой клон st-link, НО В АЛЛЮМИНЕВОМ корпусе (предыдущие были в пластике). В России таких не нашел. Заказал в Китае. Посылка пришла. Подключил. МК прошился нормально. В сети были советы по-поводу изоляции пинов. Я послушался и заизолировал. Действительно как-то стремно корпус шаркал по пинам. )))</p>
<h4>Отладка.</h4>
<p>Напомню, что вся работа идет в Linux. Что говорит о невозможности использования фирменного проограммного обеспечения от st.com. Да и скачать его сейчас не так просто: я использовал vpn с адресом Амстердама. По другому этот сайт в 2025-2026 не открывыается. САНКЦИИ!!!</p>
<p>Так вот... Что имеем? Linux, vim, sdcc, stm8flash. Все ПО свободное, есть исходный код в наличии. Остался отладчик. И пожалуй это самый важный этап. Почему? Да потому, что в каждой программе всегда есть ошибки, которые не вызывают останова компиляции. Они тихо сидят и портят нервы после запуска МК. Что-то можно отловить анализатором( а если его нет?). Что-то можно осмыслить, глядя на работу устройства. Но все же лучше, чем взглянуть на то, в каком состоянии находится МК, пока еще ничего не придумали. Поэтому и "важный" этап.</p>
